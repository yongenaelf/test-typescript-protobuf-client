// @generated by protoc-gen-es v1.7.1 with parameter "target=ts"
// @generated from file aelf/core.proto (package aelf, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * @generated from enum aelf.TransactionResultStatus
 */
export enum TransactionResultStatus {
  /**
   * The execution result of the transaction does not exist.
   *
   * @generated from enum value: NOT_EXISTED = 0;
   */
  NOT_EXISTED = 0,

  /**
   * The transaction is in the transaction pool waiting to be packaged.
   *
   * @generated from enum value: PENDING = 1;
   */
  PENDING = 1,

  /**
   * Transaction execution failed.
   *
   * @generated from enum value: FAILED = 2;
   */
  FAILED = 2,

  /**
   * The transaction was successfully executed and successfully packaged into a block.
   *
   * @generated from enum value: MINED = 3;
   */
  MINED = 3,

  /**
   * When executed in parallel, there are conflicts with other transactions.
   *
   * @generated from enum value: CONFLICT = 4;
   */
  CONFLICT = 4,

  /**
   * The transaction is waiting for validation.
   *
   * @generated from enum value: PENDING_VALIDATION = 5;
   */
  PENDING_VALIDATION = 5,

  /**
   * Transaction validation failed.
   *
   * @generated from enum value: NODE_VALIDATION_FAILED = 6;
   */
  NODE_VALIDATION_FAILED = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(TransactionResultStatus)
proto3.util.setEnumType(TransactionResultStatus, "aelf.TransactionResultStatus", [
  { no: 0, name: "NOT_EXISTED" },
  { no: 1, name: "PENDING" },
  { no: 2, name: "FAILED" },
  { no: 3, name: "MINED" },
  { no: 4, name: "CONFLICT" },
  { no: 5, name: "PENDING_VALIDATION" },
  { no: 6, name: "NODE_VALIDATION_FAILED" },
]);

/**
 * @generated from message aelf.Transaction
 */
export class Transaction extends Message<Transaction> {
  /**
   * The address of the sender of the transaction.
   *
   * @generated from field: aelf.Address from = 1;
   */
  from?: Address;

  /**
   * The address of the contract when calling a contract.
   *
   * @generated from field: aelf.Address to = 2;
   */
  to?: Address;

  /**
   * The height of the referenced block hash.
   *
   * @generated from field: int64 ref_block_number = 3;
   */
  refBlockNumber = protoInt64.zero;

  /**
   * The first four bytes of the referenced block hash.
   *
   * @generated from field: bytes ref_block_prefix = 4;
   */
  refBlockPrefix = new Uint8Array(0);

  /**
   * The name of a method in the smart contract at the To address.
   *
   * @generated from field: string method_name = 5;
   */
  methodName = "";

  /**
   * The parameters to pass to the smart contract method.
   *
   * @generated from field: bytes params = 6;
   */
  params = new Uint8Array(0);

  /**
   * When signing a transaction itâ€™s actually a subset of the fields: from/to and the target method as well as 
   * the parameter that were given. It also contains the reference block number and prefix.
   *
   * @generated from field: bytes signature = 10000;
   */
  signature = new Uint8Array(0);

  constructor(data?: PartialMessage<Transaction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aelf.Transaction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "from", kind: "message", T: Address },
    { no: 2, name: "to", kind: "message", T: Address },
    { no: 3, name: "ref_block_number", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "ref_block_prefix", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "method_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "params", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 10000, name: "signature", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Transaction {
    return new Transaction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Transaction {
    return new Transaction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Transaction {
    return new Transaction().fromJsonString(jsonString, options);
  }

  static equals(a: Transaction | PlainMessage<Transaction> | undefined, b: Transaction | PlainMessage<Transaction> | undefined): boolean {
    return proto3.util.equals(Transaction, a, b);
  }
}

/**
 * @generated from message aelf.StatePath
 */
export class StatePath extends Message<StatePath> {
  /**
   * The partial path of the state path.
   *
   * @generated from field: repeated string parts = 1;
   */
  parts: string[] = [];

  constructor(data?: PartialMessage<StatePath>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aelf.StatePath";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parts", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StatePath {
    return new StatePath().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StatePath {
    return new StatePath().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StatePath {
    return new StatePath().fromJsonString(jsonString, options);
  }

  static equals(a: StatePath | PlainMessage<StatePath> | undefined, b: StatePath | PlainMessage<StatePath> | undefined): boolean {
    return proto3.util.equals(StatePath, a, b);
  }
}

/**
 * @generated from message aelf.ScopedStatePath
 */
export class ScopedStatePath extends Message<ScopedStatePath> {
  /**
   * The scope address, which will be the contract address.
   *
   * @generated from field: aelf.Address address = 1;
   */
  address?: Address;

  /**
   * The path of contract state.
   *
   * @generated from field: aelf.StatePath path = 2;
   */
  path?: StatePath;

  constructor(data?: PartialMessage<ScopedStatePath>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aelf.ScopedStatePath";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "message", T: Address },
    { no: 2, name: "path", kind: "message", T: StatePath },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScopedStatePath {
    return new ScopedStatePath().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScopedStatePath {
    return new ScopedStatePath().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScopedStatePath {
    return new ScopedStatePath().fromJsonString(jsonString, options);
  }

  static equals(a: ScopedStatePath | PlainMessage<ScopedStatePath> | undefined, b: ScopedStatePath | PlainMessage<ScopedStatePath> | undefined): boolean {
    return proto3.util.equals(ScopedStatePath, a, b);
  }
}

/**
 * @generated from message aelf.TransactionResult
 */
export class TransactionResult extends Message<TransactionResult> {
  /**
   * The transaction id.
   *
   * @generated from field: aelf.Hash transaction_id = 1;
   */
  transactionId?: Hash;

  /**
   * The transaction result status.
   *
   * @generated from field: aelf.TransactionResultStatus status = 2;
   */
  status = TransactionResultStatus.NOT_EXISTED;

  /**
   * The log events.
   *
   * @generated from field: repeated aelf.LogEvent logs = 3;
   */
  logs: LogEvent[] = [];

  /**
   * Bloom filter for transaction logs. A transaction log event can be defined in the contract and stored 
   * in the bloom filter after the transaction is executed. Through this filter, we can quickly search for 
   * and determine whether a log exists in the transaction result.
   *
   * @generated from field: bytes bloom = 4;
   */
  bloom = new Uint8Array(0);

  /**
   * The return value of the transaction execution.
   *
   * @generated from field: bytes return_value = 5;
   */
  returnValue = new Uint8Array(0);

  /**
   * The height of the block hat packages the transaction.
   *
   * @generated from field: int64 block_number = 6;
   */
  blockNumber = protoInt64.zero;

  /**
   * The hash of the block hat packages the transaction.
   *
   * @generated from field: aelf.Hash block_hash = 7;
   */
  blockHash?: Hash;

  /**
   * Failed execution error message.
   *
   * @generated from field: string error = 10;
   */
  error = "";

  constructor(data?: PartialMessage<TransactionResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aelf.TransactionResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transaction_id", kind: "message", T: Hash },
    { no: 2, name: "status", kind: "enum", T: proto3.getEnumType(TransactionResultStatus) },
    { no: 3, name: "logs", kind: "message", T: LogEvent, repeated: true },
    { no: 4, name: "bloom", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "return_value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "block_number", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "block_hash", kind: "message", T: Hash },
    { no: 10, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionResult {
    return new TransactionResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionResult {
    return new TransactionResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionResult {
    return new TransactionResult().fromJsonString(jsonString, options);
  }

  static equals(a: TransactionResult | PlainMessage<TransactionResult> | undefined, b: TransactionResult | PlainMessage<TransactionResult> | undefined): boolean {
    return proto3.util.equals(TransactionResult, a, b);
  }
}

/**
 * @generated from message aelf.LogEvent
 */
export class LogEvent extends Message<LogEvent> {
  /**
   * The contract address.
   *
   * @generated from field: aelf.Address address = 1;
   */
  address?: Address;

  /**
   * The name of the log event.
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * The indexed data, used to calculate bloom.
   *
   * @generated from field: repeated bytes indexed = 3;
   */
  indexed: Uint8Array[] = [];

  /**
   * The non indexed data.
   *
   * @generated from field: bytes non_indexed = 4;
   */
  nonIndexed = new Uint8Array(0);

  constructor(data?: PartialMessage<LogEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aelf.LogEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "message", T: Address },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "indexed", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
    { no: 4, name: "non_indexed", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LogEvent {
    return new LogEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LogEvent {
    return new LogEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LogEvent {
    return new LogEvent().fromJsonString(jsonString, options);
  }

  static equals(a: LogEvent | PlainMessage<LogEvent> | undefined, b: LogEvent | PlainMessage<LogEvent> | undefined): boolean {
    return proto3.util.equals(LogEvent, a, b);
  }
}

/**
 * @generated from message aelf.SmartContractRegistration
 */
export class SmartContractRegistration extends Message<SmartContractRegistration> {
  /**
   * The category of contract code(0: C#).
   *
   * @generated from field: sint32 category = 1;
   */
  category = 0;

  /**
   * The byte array of the contract code.
   *
   * @generated from field: bytes code = 2;
   */
  code = new Uint8Array(0);

  /**
   * The hash of the contract code.
   *
   * @generated from field: aelf.Hash code_hash = 3;
   */
  codeHash?: Hash;

  /**
   * Whether it is a system contract.
   *
   * @generated from field: bool is_system_contract = 4;
   */
  isSystemContract = false;

  /**
   * The version of the current contract.
   *
   * @generated from field: int32 version = 5;
   */
  version = 0;

  constructor(data?: PartialMessage<SmartContractRegistration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aelf.SmartContractRegistration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "category", kind: "scalar", T: 17 /* ScalarType.SINT32 */ },
    { no: 2, name: "code", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "code_hash", kind: "message", T: Hash },
    { no: 4, name: "is_system_contract", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "version", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SmartContractRegistration {
    return new SmartContractRegistration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SmartContractRegistration {
    return new SmartContractRegistration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SmartContractRegistration {
    return new SmartContractRegistration().fromJsonString(jsonString, options);
  }

  static equals(a: SmartContractRegistration | PlainMessage<SmartContractRegistration> | undefined, b: SmartContractRegistration | PlainMessage<SmartContractRegistration> | undefined): boolean {
    return proto3.util.equals(SmartContractRegistration, a, b);
  }
}

/**
 * @generated from message aelf.TransactionExecutingStateSet
 */
export class TransactionExecutingStateSet extends Message<TransactionExecutingStateSet> {
  /**
   * The changed states.
   *
   * @generated from field: map<string, bytes> writes = 1;
   */
  writes: { [key: string]: Uint8Array } = {};

  /**
   * The read states.
   *
   * @generated from field: map<string, bool> reads = 2;
   */
  reads: { [key: string]: boolean } = {};

  /**
   * The deleted states.
   *
   * @generated from field: map<string, bool> deletes = 3;
   */
  deletes: { [key: string]: boolean } = {};

  constructor(data?: PartialMessage<TransactionExecutingStateSet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aelf.TransactionExecutingStateSet";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "writes", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 12 /* ScalarType.BYTES */} },
    { no: 2, name: "reads", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 8 /* ScalarType.BOOL */} },
    { no: 3, name: "deletes", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 8 /* ScalarType.BOOL */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionExecutingStateSet {
    return new TransactionExecutingStateSet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionExecutingStateSet {
    return new TransactionExecutingStateSet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionExecutingStateSet {
    return new TransactionExecutingStateSet().fromJsonString(jsonString, options);
  }

  static equals(a: TransactionExecutingStateSet | PlainMessage<TransactionExecutingStateSet> | undefined, b: TransactionExecutingStateSet | PlainMessage<TransactionExecutingStateSet> | undefined): boolean {
    return proto3.util.equals(TransactionExecutingStateSet, a, b);
  }
}

/**
 * @generated from message aelf.Address
 */
export class Address extends Message<Address> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<Address>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aelf.Address";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Address {
    return new Address().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Address {
    return new Address().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Address {
    return new Address().fromJsonString(jsonString, options);
  }

  static equals(a: Address | PlainMessage<Address> | undefined, b: Address | PlainMessage<Address> | undefined): boolean {
    return proto3.util.equals(Address, a, b);
  }
}

/**
 * @generated from message aelf.Hash
 */
export class Hash extends Message<Hash> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<Hash>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aelf.Hash";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Hash {
    return new Hash().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Hash {
    return new Hash().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Hash {
    return new Hash().fromJsonString(jsonString, options);
  }

  static equals(a: Hash | PlainMessage<Hash> | undefined, b: Hash | PlainMessage<Hash> | undefined): boolean {
    return proto3.util.equals(Hash, a, b);
  }
}

/**
 * @generated from message aelf.SInt32Value
 */
export class SInt32Value extends Message<SInt32Value> {
  /**
   * @generated from field: sint32 value = 1;
   */
  value = 0;

  constructor(data?: PartialMessage<SInt32Value>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aelf.SInt32Value";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 17 /* ScalarType.SINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt32Value {
    return new SInt32Value().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt32Value {
    return new SInt32Value().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt32Value {
    return new SInt32Value().fromJsonString(jsonString, options);
  }

  static equals(a: SInt32Value | PlainMessage<SInt32Value> | undefined, b: SInt32Value | PlainMessage<SInt32Value> | undefined): boolean {
    return proto3.util.equals(SInt32Value, a, b);
  }
}

/**
 * @generated from message aelf.SInt64Value
 */
export class SInt64Value extends Message<SInt64Value> {
  /**
   * @generated from field: sint64 value = 1;
   */
  value = protoInt64.zero;

  constructor(data?: PartialMessage<SInt64Value>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aelf.SInt64Value";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 18 /* ScalarType.SINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt64Value {
    return new SInt64Value().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt64Value {
    return new SInt64Value().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt64Value {
    return new SInt64Value().fromJsonString(jsonString, options);
  }

  static equals(a: SInt64Value | PlainMessage<SInt64Value> | undefined, b: SInt64Value | PlainMessage<SInt64Value> | undefined): boolean {
    return proto3.util.equals(SInt64Value, a, b);
  }
}

/**
 * @generated from message aelf.MerklePath
 */
export class MerklePath extends Message<MerklePath> {
  /**
   * The merkle path nodes.
   *
   * @generated from field: repeated aelf.MerklePathNode merkle_path_nodes = 1;
   */
  merklePathNodes: MerklePathNode[] = [];

  constructor(data?: PartialMessage<MerklePath>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aelf.MerklePath";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "merkle_path_nodes", kind: "message", T: MerklePathNode, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MerklePath {
    return new MerklePath().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MerklePath {
    return new MerklePath().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MerklePath {
    return new MerklePath().fromJsonString(jsonString, options);
  }

  static equals(a: MerklePath | PlainMessage<MerklePath> | undefined, b: MerklePath | PlainMessage<MerklePath> | undefined): boolean {
    return proto3.util.equals(MerklePath, a, b);
  }
}

/**
 * @generated from message aelf.MerklePathNode
 */
export class MerklePathNode extends Message<MerklePathNode> {
  /**
   * The node hash.
   *
   * @generated from field: aelf.Hash hash = 1;
   */
  hash?: Hash;

  /**
   * Whether it is a left child node.
   *
   * @generated from field: bool is_left_child_node = 2;
   */
  isLeftChildNode = false;

  constructor(data?: PartialMessage<MerklePathNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aelf.MerklePathNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hash", kind: "message", T: Hash },
    { no: 2, name: "is_left_child_node", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MerklePathNode {
    return new MerklePathNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MerklePathNode {
    return new MerklePathNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MerklePathNode {
    return new MerklePathNode().fromJsonString(jsonString, options);
  }

  static equals(a: MerklePathNode | PlainMessage<MerklePathNode> | undefined, b: MerklePathNode | PlainMessage<MerklePathNode> | undefined): boolean {
    return proto3.util.equals(MerklePathNode, a, b);
  }
}

/**
 * @generated from message aelf.BinaryMerkleTree
 */
export class BinaryMerkleTree extends Message<BinaryMerkleTree> {
  /**
   * The leaf nodes.
   *
   * @generated from field: repeated aelf.Hash nodes = 1;
   */
  nodes: Hash[] = [];

  /**
   * The root node hash.
   *
   * @generated from field: aelf.Hash root = 2;
   */
  root?: Hash;

  /**
   * The count of leaf node.
   *
   * @generated from field: int32 leaf_count = 3;
   */
  leafCount = 0;

  constructor(data?: PartialMessage<BinaryMerkleTree>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aelf.BinaryMerkleTree";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nodes", kind: "message", T: Hash, repeated: true },
    { no: 2, name: "root", kind: "message", T: Hash },
    { no: 3, name: "leaf_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BinaryMerkleTree {
    return new BinaryMerkleTree().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BinaryMerkleTree {
    return new BinaryMerkleTree().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BinaryMerkleTree {
    return new BinaryMerkleTree().fromJsonString(jsonString, options);
  }

  static equals(a: BinaryMerkleTree | PlainMessage<BinaryMerkleTree> | undefined, b: BinaryMerkleTree | PlainMessage<BinaryMerkleTree> | undefined): boolean {
    return proto3.util.equals(BinaryMerkleTree, a, b);
  }
}

/**
 * @generated from message aelf.BigIntValue
 */
export class BigIntValue extends Message<BigIntValue> {
  /**
   * @generated from field: string value = 1;
   */
  value = "";

  constructor(data?: PartialMessage<BigIntValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aelf.BigIntValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BigIntValue {
    return new BigIntValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BigIntValue {
    return new BigIntValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BigIntValue {
    return new BigIntValue().fromJsonString(jsonString, options);
  }

  static equals(a: BigIntValue | PlainMessage<BigIntValue> | undefined, b: BigIntValue | PlainMessage<BigIntValue> | undefined): boolean {
    return proto3.util.equals(BigIntValue, a, b);
  }
}

